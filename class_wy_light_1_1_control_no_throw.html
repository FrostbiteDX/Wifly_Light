<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Wifly_Light: WyLight::ControlNoThrow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Wifly_Light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_wy_light.html">WyLight</a></li><li class="navelem"><a class="el" href="class_wy_light_1_1_control_no_throw.html">ControlNoThrow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_wy_light_1_1_control_no_throw-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WyLight::ControlNoThrow Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to communicate with a Wifly_Light Hardware.  
 <a href="class_wy_light_1_1_control_no_throw.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_wifly_control_no_throw_8h_source.html">WiflyControlNoThrow.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a904cf007af9dad72fc9f561e5bf3fcbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a904cf007af9dad72fc9f561e5bf3fcbf">ControlNoThrow</a> (uint32_t addr, uint16_t port)</td></tr>
<tr class="separator:a904cf007af9dad72fc9f561e5bf3fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a84bbb426ef1b98f1f4f01e4c3c69c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a4a84bbb426ef1b98f1f4f01e4c3c69c5">BlEnableAutostart</a> (void) const </td></tr>
<tr class="separator:a4a84bbb426ef1b98f1f4f01e4c3c69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba41a8dff954ad4e2a69507ffb063d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a5fba41a8dff954ad4e2a69507ffb063d">BlEraseEeprom</a> (void) const </td></tr>
<tr class="separator:a5fba41a8dff954ad4e2a69507ffb063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9296834b2cdce95fc151f06042babf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#aff9296834b2cdce95fc151f06042babf">BlEraseFlash</a> (void) const </td></tr>
<tr class="separator:aff9296834b2cdce95fc151f06042babf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8005c5dd9fff473bb43c59c956c4a772"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a8005c5dd9fff473bb43c59c956c4a772">BlProgramFlash</a> (const std::string &amp;filename) const </td></tr>
<tr class="separator:a8005c5dd9fff473bb43c59c956c4a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7544aca0b4ca8bbadfea5bb1be728cb2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a7544aca0b4ca8bbadfea5bb1be728cb2">BlReadCrcFlash</a> (std::ostream &amp;out, uint32_t address, size_t numBlocks) const </td></tr>
<tr class="separator:a7544aca0b4ca8bbadfea5bb1be728cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dee62bcd9806fe3f521793312ba30a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a49dee62bcd9806fe3f521793312ba30a">BlReadEeprom</a> (std::ostream &amp;out, uint32_t address, size_t numBytes) const </td></tr>
<tr class="separator:a49dee62bcd9806fe3f521793312ba30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20162c1a357bd55488552eca0d5872ca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a20162c1a357bd55488552eca0d5872ca">BlReadFlash</a> (std::ostream &amp;out, uint32_t address, size_t numBytes) const </td></tr>
<tr class="separator:a20162c1a357bd55488552eca0d5872ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cd174ece3a779b605a8e3c3e9f2f82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a79cd174ece3a779b605a8e3c3e9f2f82">BlReadFwVersion</a> (std::string &amp;versionString) const </td></tr>
<tr class="separator:a79cd174ece3a779b605a8e3c3e9f2f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf73db9a4da4dfc1330e14cbf47864e3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#acf73db9a4da4dfc1330e14cbf47864e3">BlReadInfo</a> (<a class="el" href="struct_bl_info.html">BlInfo</a> &amp;info) const </td></tr>
<tr class="separator:acf73db9a4da4dfc1330e14cbf47864e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d301c3983548d341890ea4291c9854"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#ab5d301c3983548d341890ea4291c9854">BlRunApp</a> (void) const </td></tr>
<tr class="separator:ab5d301c3983548d341890ea4291c9854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e8e289fa6eb33dce5c7e262be3eecb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#af3e8e289fa6eb33dce5c7e262be3eecb">ConfGetSsid</a> (std::string &amp;ssid) const </td></tr>
<tr class="separator:af3e8e289fa6eb33dce5c7e262be3eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e2d2a39eb4ab9f4780025be68cfe90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a91e2d2a39eb4ab9f4780025be68cfe90">ConfModuleAsSoftAP</a> (const std::string &amp;accesspointName=&quot;Wifly_Light&quot;) const </td></tr>
<tr class="separator:a91e2d2a39eb4ab9f4780025be68cfe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31690542e9bba1c304235cf099c77365"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a31690542e9bba1c304235cf099c77365">ConfModuleForWlan</a> (const std::string &amp;phrase, const std::string &amp;ssid, const std::string &amp;name=&quot;Wifly_Light&quot;) const </td></tr>
<tr class="separator:a31690542e9bba1c304235cf099c77365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ae25973e8f7943045ed4710cfba3cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#ab6ae25973e8f7943045ed4710cfba3cf">ConfRebootWlanModule</a> (void) const </td></tr>
<tr class="separator:ab6ae25973e8f7943045ed4710cfba3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa980bed9ae47bdab43f5987a41681d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a1aa980bed9ae47bdab43f5987a41681d">ConfSetDeviceId</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a1aa980bed9ae47bdab43f5987a41681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affad92c25b64a0206b25af3fc538c4d3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#affad92c25b64a0206b25af3fc538c4d3">FwClearScript</a> (void)</td></tr>
<tr class="separator:affad92c25b64a0206b25af3fc538c4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af206ee9a6c7333d0ef38168c978c72c7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#af206ee9a6c7333d0ef38168c978c72c7">FwGetCycletime</a> (std::string &amp;output)</td></tr>
<tr class="separator:af206ee9a6c7333d0ef38168c978c72c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eeaa249f73f511890e9d3feb9a3c6f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a85eeaa249f73f511890e9d3feb9a3c6f">FwGetRtc</a> (tm &amp;timeValue)</td></tr>
<tr class="separator:a85eeaa249f73f511890e9d3feb9a3c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa725063c85bbe01b94d8fd868119dbab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#aa725063c85bbe01b94d8fd868119dbab">FwGetTracebuffer</a> (std::string &amp;output)</td></tr>
<tr class="separator:aa725063c85bbe01b94d8fd868119dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c2375f32c7c5b2679dac095e1adbd1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a63c2375f32c7c5b2679dac095e1adbd1">FwGetVersion</a> (std::string &amp;output)</td></tr>
<tr class="separator:a63c2375f32c7c5b2679dac095e1adbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace76fa87789fc3b36c709ec5a57f8f3c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#ace76fa87789fc3b36c709ec5a57f8f3c">FwLoopOff</a> (const uint8_t numLoops)</td></tr>
<tr class="separator:ace76fa87789fc3b36c709ec5a57f8f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe18abf5c2770714da51da98cc1adb15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#abe18abf5c2770714da51da98cc1adb15">FwLoopOn</a> (void)</td></tr>
<tr class="separator:abe18abf5c2770714da51da98cc1adb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321d6c6d302050dee940e8fb10991c95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a321d6c6d302050dee940e8fb10991c95">FwSetColorDirect</a> (const uint8_t *pBuffer, const size_t bufferLength)</td></tr>
<tr class="separator:a321d6c6d302050dee940e8fb10991c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b852a289a48a450efc3ffd91edb7832"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a6b852a289a48a450efc3ffd91edb7832">FwSetFade</a> (const uint32_t argb, const uint16_t fadeTime=0, const uint32_t addr=0xffffffff, const bool parallelFade=false)</td></tr>
<tr class="separator:a6b852a289a48a450efc3ffd91edb7832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d50d589698cd976dec870710d1d628a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a1d50d589698cd976dec870710d1d628a">FwSetGradient</a> (const uint32_t argb_1, const uint32_t argb_2, const uint16_t fadeTime=0, const bool parallelFade=false, const uint8_t length=NUM_OF_LED, const uint8_t offset=0)</td></tr>
<tr class="separator:a1d50d589698cd976dec870710d1d628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d493b1081707246bafa7be52f8db49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a57d493b1081707246bafa7be52f8db49">FwSetRtc</a> (const tm &amp;timeValue)</td></tr>
<tr class="separator:a57d493b1081707246bafa7be52f8db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124a9c7b09966ce9f717b1058ab0ac54"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#a124a9c7b09966ce9f717b1058ab0ac54">FwSetWait</a> (const uint16_t waitTime)</td></tr>
<tr class="separator:a124a9c7b09966ce9f717b1058ab0ac54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94183c86828b1a223c46fec3c04c285"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wy_light_1_1_control_no_throw.html#ae94183c86828b1a223c46fec3c04c285">FwStartBl</a> (void)</td></tr>
<tr class="separator:ae94183c86828b1a223c46fec3c04c285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to communicate with a Wifly_Light Hardware. </p>
<p>The <a class="el" href="class_wy_light_1_1_control_no_throw.html" title="Class to communicate with a Wifly_Light Hardware.">ControlNoThrow</a> class allows the user to control the Wifly_Light hardware. This is a wrapper class to <a class="el" href="class_wy_light_1_1_control.html">WyLight::Control</a> to catch all exceptions from the lower software layers and convert them into error codes, which is required for example for jni or iOS clients There are three target's at the Wifly_Light Hardware.</p>
<ul>
<li>Bootloader<br/>
 All methodes with Bl* relate to the bootloader part.</li>
<li>Firmware<br/>
 All methodes with Fw* relate to the firmware part.</li>
<li>RN-171 Wifi Interface<br/>
 All methodes witch Conf* relate to the communication module. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a904cf007af9dad72fc9f561e5bf3fcbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WyLight::ControlNoThrow::ControlNoThrow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to a wifly device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>ipv4 address as 32 bit value in host byte order </td></tr>
    <tr><td class="paramname">port</td><td>number of the wifly device server in host byte order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4a84bbb426ef1b98f1f4f01e4c3c69c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlEnableAutostart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to set the autostart flag to true. This ensures the bootloader will be started on the next reboot automatically. </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a5fba41a8dff954ad4e2a69507ffb063d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlEraseEeprom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to erase the whole eeprom. The wifly device has to be in bootloader mode for this command. </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="aff9296834b2cdce95fc151f06042babf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlEraseFlash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to erase the whole flash which is not occupied by the bootloader itself. The wifly device has to be in bootloader mode for this command. </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a8005c5dd9fff473bb43c59c956c4a772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlProgramFlash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to update the wifly device with new firmware. The wifly device has to be in bootloader mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>path to the *.hex file containing the new firmware </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a7544aca0b4ca8bbadfea5bb1be728cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlReadCrcFlash </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to create crc-16 checksums for the content of the specified flash area. TODO crc values are in little endian byte order The wifly device has to be in bootloader mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>ostream for the resulting 16bit crc values </td></tr>
    <tr><td class="paramname">address</td><td>crc generation starts from this flash address </td></tr>
    <tr><td class="paramname">numBlocks</td><td>size of the flash area for which the crc are calculated. One block contains 64 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>INVALID_PARAMETER</b> if a parameter is out of bound <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a49dee62bcd9806fe3f521793312ba30a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlReadEeprom </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to read the specified memory area of the eeprom. The wifly device has to be in bootloader mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>ostream where the eeprom content is written </td></tr>
    <tr><td class="paramname">address</td><td>start of the eeprom region to read </td></tr>
    <tr><td class="paramname">numBytes</td><td>size of the eeprom region to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>INVALID_PARAMETER</b> if a parameter is out of bound <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a20162c1a357bd55488552eca0d5872ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlReadFlash </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to read the specified memory area of the flash. The wifly device has to be in bootloader mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>ostream where the eeprom content is written </td></tr>
    <tr><td class="paramname">address</td><td>start of the flash region to readRequest </td></tr>
    <tr><td class="paramname">numBytes</td><td>size of the flash region to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>INVALID_PARAMETER</b> if a parameter is out of bound <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a79cd174ece3a779b605a8e3c3e9f2f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlReadFwVersion </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>versionString</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to read the version string from the firmware memory. The wifly device has to be in bootloader mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">versionString</td><td>is the returnvalue for the firmware version from pic memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="acf73db9a4da4dfc1330e14cbf47864e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlReadInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bl_info.html">BlInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to return a struct of bootloader informations like bootloader version, flash and eeprom size. see <a class="el" href="struct_bl_info.html">BlInfo</a> for details. The wifly device has to be in bootloader mode for this command. </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d301c3983548d341890ea4291c9854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::BlRunApp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the bootloader to start the wifly device firmware. The wifly device has to be in bootloader mode for this command. </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="af3e8e289fa6eb33dce5c7e262be3eecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::ConfGetSsid </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ssid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the currently configured ssid from <a class="el" href="namespace_wy_light.html" title="Class to communicate with a Wifly_Light Hardware.">WyLight</a> module </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssid</td><td>is the outputstring for the current ssid set in the RN-171 WLAN modul </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a91e2d2a39eb4ab9f4780025be68cfe90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::ConfModuleAsSoftAP </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>accesspointName</em> = <code>&quot;Wifly_Light&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configurates the <a class="el" href="namespace_wy_light.html" title="Class to communicate with a Wifly_Light Hardware.">WyLight</a> module as stand alone accesspoint. With accesspoint name you can change the ssid for this accesspoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accesspointName</td><td>1 - 32 characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>FATAL_ERROR</b> in case of an error <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a31690542e9bba1c304235cf099c77365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::ConfModuleForWlan </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>phrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ssid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Wifly_Light&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configurates the <a class="el" href="namespace_wy_light.html" title="Class to communicate with a Wifly_Light Hardware.">WyLight</a> module as client for an existing wlan network with WPA2 protection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phrase</td><td>WPA2 passphrase 1 - 63 characters </td></tr>
    <tr><td class="paramname">ssid</td><td>1 - 32 characters </td></tr>
    <tr><td class="paramname">name</td><td>1 - 32 characters, unique name which apperas in the broadcast message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>FATAL_ERROR</b> in case of an error <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ae25973e8f7943045ed4710cfba3cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::ConfRebootWlanModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reboot the modul. ATTENTION: You have to reconnect after a reboot </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>FATAL_ERROR</b> in case of an error <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a1aa980bed9ae47bdab43f5987a41681d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::ConfSetDeviceId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows you to give every Wifly_Light device an unique name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>1 - 32 characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>FATAL_ERROR</b> in case of an error <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="affad92c25b64a0206b25af3fc538c4d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwClearScript </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wipe all commands from the <a class="el" href="namespace_wy_light.html" title="Class to communicate with a Wifly_Light Hardware.">WyLight</a> script controller </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="af206ee9a6c7333d0ef38168c978c72c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwGetCycletime </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the cycletimes from wifly device and stores them into the response object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>string with all recorded cycletimes from PIC firmware </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a85eeaa249f73f511890e9d3feb9a3c6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwGetRtc </td>
          <td>(</td>
          <td class="paramtype">tm &amp;&#160;</td>
          <td class="paramname"><em>timeValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the current rtc time from the wifly device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeValue</td><td>reference to a tm object, where to store the rtc time from PIC firmware </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="aa725063c85bbe01b94d8fd868119dbab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwGetTracebuffer </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the tracebuffer from wifly device and stores the data into the response object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>a string with all recorded trace messages from PIC firmware </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a63c2375f32c7c5b2679dac095e1adbd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwGetVersion </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the firmware version currently running on the wifly device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>a string representing the version number of the PIC firmware </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ace76fa87789fc3b36c709ec5a57f8f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwLoopOff </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>numLoops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a LoopOff command into the wifly script controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numLoops</td><td>number of rounds before termination of the loop, use 0 for infinite loops. To terminate an infinite loop you have to call &lt;FwClearScript&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="abe18abf5c2770714da51da98cc1adb15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwLoopOn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a LoopOn command into the wifly script controller </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a321d6c6d302050dee940e8fb10991c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwSetColorDirect </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all leds with different colors directly. This doesn't affect the <a class="el" href="namespace_wy_light.html" title="Class to communicate with a Wifly_Light Hardware.">WyLight</a> script controller Example: to set the first led to yellow and the second to blue and all others to off use a &lt;pBuffer&gt; like this: pBuffer[] = {0xff, 0xff, 0x00, 0x00, 0x00, 0xff}; bufferLength = 6; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>containing continouse rgb values r1g1b1r2g2b2...r32g32b32 </td></tr>
    <tr><td class="paramname">bufferLength</td><td>number of bytes in &lt;pBuffer&gt; usally 32 * 3 bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a6b852a289a48a450efc3ffd91edb7832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwSetFade </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>argb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>fadeTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>parallelFade</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a fade command into the wifly script controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argb</td><td>is a 32 bit rgb value with unused alpha channel (set alpha always to 0xff) f.e. black(  0,  0,  0) as argb is 0xff000000 green(  0,255,  0) as argb is 0xff00ff00 white(255,255,255) as argb is 0xffffffff </td></tr>
    <tr><td class="paramname">fadeTime</td><td>in hundreths of a second. Use 0 to set color immediately, default = 0 </td></tr>
    <tr><td class="paramname">addr</td><td>bitmask of leds which should be effected by this command, set bit to 1 to affect the led, default 0xffffffff </td></tr>
    <tr><td class="paramname">parallelFade</td><td>if true other fades are allowed in parallel with this fade </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a1d50d589698cd976dec870710d1d628a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwSetGradient </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>argb_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>argb_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>fadeTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>parallelFade</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>NUM_OF_LED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a gradient command into the wifly script controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argb_1</td><td>is a 32 bit rgb value with unused alpha channel (set alpha always to 0xff). This is the start color for the gradient. </td></tr>
    <tr><td class="paramname">argb_2</td><td>is a 32 bit rgb value with unused alpha channel (set alpha always to 0xff). This is the end color for the gradient. </td></tr>
    <tr><td class="paramname">fadeTime</td><td>in hundreths of a second. Use 0 to set color immediately, default = 0 </td></tr>
    <tr><td class="paramname">parallelFade</td><td>if true other fades are allowed in parallel with this fade </td></tr>
    <tr><td class="paramname">length</td><td>is the number of led's from startposition to endposition </td></tr>
    <tr><td class="paramname">offset</td><td>can be used to move the startposition of the gradient on the ledstrip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed, or a invalid value for offset <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a57d493b1081707246bafa7be52f8db49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwSetRtc </td>
          <td>(</td>
          <td class="paramtype">const tm &amp;&#160;</td>
          <td class="paramname"><em>timeValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the rtc clock of the wifly device to the specified time. The wifly device has to be in firmware mode for this command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeValue</td><td>pointer to a posix tm struct containing the new time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a124a9c7b09966ce9f717b1058ab0ac54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwSetWait </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>waitTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects a wait command into the wifly script controller. This causes the script processing to wait before executing the next command for the specified duration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitTime</td><td>in hundreths of a second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed &lt; BR&gt;<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ae94183c86828b1a223c46fec3c04c285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WyLight::ControlNoThrow::FwStartBl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops firmware and script controller execution and start the bootloader of the wifly device </p>
<dl class="section return"><dt>Returns</dt><dd>Indexed by <a class="el" href="namespace_wy_light.html#afd625f917b07e9c48f67c4383af5773f">WiflyError</a> <br/>
<b>CONNECTION_TIMEOUT</b> if response timed out <br/>
<b>FATAL_ERROR</b> if command code of the response doesn't match the code of the request, or too many retries failed <br/>
<b>SCRIPT_FULL</b> if script buffer in PIC firmware is full and request couldn't be executed <br/>
<b>NO_ERROR</b> is returned if no error occurred </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>library/<a class="el" href="_wifly_control_no_throw_8h_source.html">WiflyControlNoThrow.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 8 2013 17:54:36 for Wifly_Light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
